箭头函数是为了消除传统函数中 `this` 指向不明确的问题而引入的。它简化了函数的写法，特别适用于需要捕获外层上下文的场景。箭头函数本质上是更简洁的函数表达式，用于简化回调函数的编写，同时避免 `this` 的二义性。

- **没有自己的 `this` 绑定**：箭头函数不会创建自己的 `this`，它会捕获其定义时的上下文中的 `this`，这使得它特别适合用在回调函数中，比如事件处理程序中。这意味着箭头函数的 `this` 总是指向定义时的作用域，而不是调用时的作用域。
- **不能作为构造函数**：由于箭头函数没有 `this`，它不能用作构造函数，也不能与 `new` 操作符一起使用。如果尝试用 `new` 操作符调用箭头函数，将会抛出错误。
- **没有自己的 `arguments` 对象**：箭头函数没有自己的 `arguments` 对象，如果需要使用，可以通过外层函数的 `arguments` 对象访问。
- **不能使用 `call`、`apply`、`bind` 改变 `this` 指向**：箭头函数的 `this` 是静态的，无法通过 `call`、`apply`、`bind` 来改变其 `this` 的指向。
- **不具备 `prototype` 属性**：箭头函数没有 `prototype` 属性，因此它们不能被用作构造函数来创建对象。

总结来说，箭头函数的主要作用在于简化回调函数的编写，特别适合需要访问定义时的上下文的场景。它不是面向对象的构造器，因此缺少了传统函数的一些面向对象特性（如 `this` 指向变化、`prototype` 等）。

---

箭头函数的特点：

> 1. 语法简洁；
> 2. 没有自己的 this；
> 3. 不能用作构造函数；
> 4. 不能使用 arguments 对象；
> 5. 没有 super；

箭头函数和普通函数的区别：

> 1. 箭头函数没有 this，普通函数有 this；
> 2. 箭头函数没有 arguments，普通函数有 arguments；
> 3. 箭头函数没有 prototype，普通函数有 prototype；

箭头函数可以通过 new 调用吗？为什么？

> 不可以。
> 因为箭头函数中没有 this。

在 class 内定义一个箭头函数和定义一个普通函数会有什么区别？

> `this`方面
>
> **普通函数**：普通函数的 `this` 指向是动态的，取决于函数的调用方式。在类的方法中，`this` 通常指向该类的实例对象。如果函数被作为事件处理程序或通过其他方式调用（例如传递给另一个函数），则需要使用 `bind()` 手动绑定 `this` 指向实例，或者使用其他方法确保 `this` 的正确性。
>
> **箭头函数**：箭头函数没有自己的 `this`，它会捕获其定义时的 `this`（词法作用域）。因此，箭头函数内的 `this` 永远指向创建它的环境中的 `this`，通常是类的实例。箭头函数不会因为调用方式的不同而改变 `this` 指向。
>
> 普通函数: `this` 的值取决于函数的调用方式。
>
> 箭头函数: `this` 的值继承自外围作用域（通常是类实例）。

> 函数内传入的arguments对象和作用域
>
> 普通函数: 有自己的 `arguments` 对象。可以访问函数传入的参数。普通函数可以作为构造函数使用。
>
> 箭头函数: 没有自己的 `arguments` 对象，但可以访问外围作用域的 `arguments`。

> 性能开销
>
> **普通函数**：普通函数是定义在类的原型上的。所有实例共享同一个函数对象，这样可以节省内存，尤其是在创建多个类实例时。
>
> **箭头函数**：箭头函数在每次创建类的实例时都会在实例上创建一个新的函数对象。这样会导致每个实例都有自己的一份方法副本，会占用更多内存空间。这种方式适用于需要在实例级别上定义方法的情况。